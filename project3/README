TO RUN THE APPLICATIONS:
- First need to set the needed environment variables for Spark by running:
  `source ~/run.sh`
- Start Spark by running:
  `start_spark`
- To run an application:
  `~/grader_assign3/part-b/file-name.sh`

LOGIC OF THE APPLICATIONS:
- App 1 - Q1:
  + First we initialize the graph by using `GraphLoader.edgeListFile` to load the soc-LiveJournal1 file.
  + We then use the page rank algorithm implemented using GraphX
- App 2 - Q1:
  + We first build a list of vertices for all interval. Each vertex stores the list of common words in that interval.
  + Then, we build an inverted index on all the words to point to the vertex which contain it. The edges is built by getting all pairs of vertices for all words and then take distinct.
  + The graph is built by the vertices and edges above
  + We then update all the vertices of the graph with the count of words in its properties.
  + We then update all edges with properties: source words count and destination words count
  + Finally, we filter the graph edges to get edges with source words count larger than destination words count
  + Size of the filted edges is the answer
- App 2 - Q2:
  + Initialize the graph like in App 2 - Q1
  + We update all the vertices of the graph with: outdegree of the vertex, words count of that vertex
  + We then sort the vertices list by outdegree and words count.
  + Head of the sorted vertices list is the answer.
- App 2 - Q3:
  + Initialize the graph like in App 2 - Q1
  + We update all the vertices of the graph with: outdegree of the vertex, words count of that vertex
  + We use `aggregateMessages` of GraphX to send the number of words count of a vertex to its neighbors and update the total words count of the destination vertex.
  + Finally, we filter the vertices list of the graph so that we only get vertices with outdegree > 0. Then we get the average number of words count for each vertex and sort the list.
- App 2 - Q4:
  + We build the inverted index like in App 2 - Q1.
  + We sort the index descending using the count of number of vertices for the corresponding word.
  + The head of the index is the result
- App 2 - Q5:
  + Initialize the graph like in App 2 - Q1
  + We first update all vertices of the graph with a set of vertexId of itself.
  + We then use `aggregateMessages` to send the set of vertexId to all of its neighbor and union the two set. With this, each vertices will store the list of all vertices in its subgraph.
  + We then sort the vertices list based on the size of its subgraph.
  + The first one in the list is the answer.
- App 2 - Q6:
  + Initialize the graph like in App 2 - Q1
  + Find the most popular word like in App 2 - Q4
  + Filter the list of vertices of the graph such that only we only keep the vertices that contain the word.
  + The size of the filtered list is our answer
